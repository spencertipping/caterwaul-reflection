// Reflection | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module adds deep reflective capabilities to Javascript. In particular, if you transform your code with it you can:

// | 1. Inspect and modify closure state.
//   2. Inspect object prototype membership (this lets you identify superclasses).

// To do this, it instruments your source code with refs that it controls. You can then ask it questions about the state of a running program. For example:

// | f = caterwaul('js_all reflection')(function (x, y) {
//     return function (z) {
//       return "x + y + z".qf}});
//   g = f(10, 15)(20);
//   caterwaul.reflection.state(g)                         // -> {x: 10, y: 15, z: 20}
//   caterwaul.reflection.scope(g)                         // -> {z: 20, '<id>': 'gensym_1', '<parent>': {x: 10, y: 15, '<id>': 'gensym_2'}}

// Gensyms are used so that you can reconstruct a scope tree. For example:

// | partial_f_1 = f(10, 15);
//   s1 = caterwaul.reflection.scope(partial_f_1(20))      // -> {z: 20, '<id>': 'gensym_2', '<parent>': {x: 10, y: 15, '<id>': 'gensym_1'}}
//   s2 = caterwaul.reflection.scope(partial_f_1(20))      // -> {z: 20, '<id>': 'gensym_3', '<parent>': {x: 10, y: 15, '<id>': 'gensym_1'}}
//   partial_f_2 = f(10, 15);
//   s3 = caterwaul.reflection.scope(partial_f_2(20))      // -> {z: 20, '<id>': 'gensym_5', '<parent>': {x: 10, y: 15, '<id>': 'gensym_4'}}

// Note that this alone isn't enough information to reliably construct the original tree of functions. To do that in the general case, you'll also need the original argument lists that were
// passed into the constructors. Here's why:

// | f = caterwaul('js_all reflection')(function (x, y) {
//     return y & 1 ? "x".qf : "x + 1".qf});
//   g1 = f(10, 0);
//   g2 = f(10, 1);
//   caterwaul.reflection.scope(g1)                        // -> {x: 10, '<id>': 'gensym_1'}
//   caterwaul.reflection.scope(g2)                        // -> {x: 10, '<id>': 'gensym_2'}

// This happens because Caterwaul doesn't modify the GC overhead of closures by introducing fictitious references. Because the only reason to keep 'y' around is to remember the decision for ?:,
// Caterwaul doesn't store it. This means that you'll need to know which decision was made if you want to reconstruct g1 or g2.

// Clearly this sucks. So the reflection module gives you a nice alternative: You can recompile a function into one that operates directly on first-class closure scopes. This means that you can
// emulate the behavior of a function even after serialization. For example:

// | serialize(f)   = {f: f.toString(), scope: caterwaul.reflection.scope(f)};
//   deserialize(o) = caterwaul.reflection.lift(caterwaul.parse(o.f), o.scope);

// Now deserialize(serialize(f)) will have behavior identical to f for functions whose toString() returns that function's source accurately.
// Generated by SDoc 
